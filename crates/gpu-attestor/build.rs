use std::env;
use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;

fn main() {
    // Handle validator key embedding
    embed_validator_key();

    // Handle CUDA linking if feature is enabled
    if env::var("CARGO_FEATURE_CUDA").is_ok() {
        link_cuda();
    }

    // Handle PTX compilation for CUDA Driver API
    compile_ptx_kernels();
}

fn embed_validator_key() {
    // For development/testing, use a default key if not provided
    let validator_key = env::var("VALIDATOR_PUBLIC_KEY").unwrap_or_else(|_| {
        eprintln!("ERROR: VALIDATOR_PUBLIC_KEY environment variable not set");
        eprintln!();
        eprintln!("To build gpu-attestor, you need to provide a validator public key.");
        eprintln!();
        eprintln!("Option 1: Generate a new key pair");
        eprintln!("  ./scripts/gen-key.sh");
        eprintln!("  This will create public_key.hex which will be automatically detected");
        eprintln!();
        eprintln!("Option 2: Use the build script directly with a key");
        eprintln!("  ./scripts/gpu-attestor/build.sh --key <YOUR_PUBLIC_KEY_HEX>");
        eprintln!();
        eprintln!("Option 3: Set environment variable");
        eprintln!("  export VALIDATOR_PUBLIC_KEY=<YOUR_PUBLIC_KEY_HEX>");
        eprintln!();
        eprintln!("The key must be a 66-character hex string (compressed P256 public key)");
        panic!("No validator key found - cannot build gpu-attestor");
    });

    // Validate hex format
    let key_bytes = match hex::decode(&validator_key) {
        Ok(bytes) => bytes,
        Err(e) => panic!("VALIDATOR_PUBLIC_KEY must be valid hex: {e}"),
    };

    // Validate key length (33 bytes for compressed P256 public key)
    if key_bytes.len() != 33 {
        panic!(
            "VALIDATOR_PUBLIC_KEY must be exactly 33 bytes (66 hex chars) for compressed P256 key, got {} bytes",
            key_bytes.len()
        );
    }

    // Validate that the key is a valid compressed P256 public key
    // First byte must be 0x02 or 0x03 for compressed format
    if key_bytes[0] != 0x02 && key_bytes[0] != 0x03 {
        panic!(
            "VALIDATOR_PUBLIC_KEY must be a valid compressed P256 public key (first byte must be 0x02 or 0x03, got 0x{:02x})",
            key_bytes[0]
        );
    }

    // Generate code that embeds the key
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("embedded_keys.rs");

    let content = format!(
        r#"// Auto-generated by build.rs - DO NOT EDIT
pub const EMBEDDED_VALIDATOR_KEY: &[u8] = &{key_bytes:?};
"#
    );

    fs::write(&dest_path, content).unwrap();

    println!("cargo:rerun-if-env-changed=VALIDATOR_PUBLIC_KEY");
}

fn link_cuda() {
    println!("cargo:rerun-if-env-changed=CUDA_PATH");
    println!("cargo:rerun-if-env-changed=CUDA_ROOT");
    println!("cargo:rerun-if-env-changed=CUDA_HOME");
    println!("cargo:rerun-if-env-changed=CUDA_TOOLKIT_ROOT_DIR");

    // Find CUDA installation
    let cuda_path = find_cuda_path();

    if let Some(cuda_path) = cuda_path {
        // Add CUDA library paths
        let lib_path = if cfg!(target_os = "windows") {
            cuda_path.join("lib").join("x64")
        } else if cfg!(target_os = "linux") {
            // Check both lib64 and lib/x86_64-linux-gnu
            if cuda_path.join("lib64").exists() {
                cuda_path.join("lib64")
            } else if cuda_path.join("lib").join("x86_64-linux-gnu").exists() {
                cuda_path.join("lib").join("x86_64-linux-gnu")
            } else {
                cuda_path.join("lib")
            }
        } else if cfg!(target_os = "macos") {
            cuda_path.join("lib")
        } else {
            panic!("Unsupported OS for CUDA");
        };

        println!("cargo:rustc-link-search=native={}", lib_path.display());

        // Link required CUDA libraries
        println!("cargo:rustc-link-lib=cudart"); // CUDA Runtime
        println!("cargo:rustc-link-lib=cuda"); // CUDA Driver
        println!("cargo:rustc-link-lib=nvrtc"); // NVRTC for runtime compilation
        println!("cargo:rustc-link-lib=curand"); // cuRAND for random number generation
        println!("cargo:rustc-link-lib=cublas"); // cuBLAS for tensor core operations

        // Add rpath for Linux to find libraries at runtime
        if cfg!(target_os = "linux") {
            println!("cargo:rustc-link-arg=-Wl,-rpath,{}", lib_path.display());
        }

        // Set CUDA_HOME for any dependencies that might need it
        env::set_var("CUDA_HOME", &cuda_path);

        println!("cargo:warning=CUDA found at: {}", cuda_path.display());
    } else {
        // CUDA not found, but feature is requested
        println!("cargo:warning=CUDA feature enabled but CUDA toolkit not found!");
        println!("cargo:warning=Please install CUDA toolkit or set CUDA_PATH environment variable");
        println!("cargo:warning=GPU benchmarks will use fallback estimation methods");
    }
}

fn find_cuda_path() -> Option<PathBuf> {
    // Check environment variables first
    if let Ok(cuda_path) = env::var("CUDA_PATH") {
        return Some(PathBuf::from(cuda_path));
    }

    if let Ok(cuda_root) = env::var("CUDA_ROOT") {
        return Some(PathBuf::from(cuda_root));
    }

    if let Ok(cuda_home) = env::var("CUDA_HOME") {
        return Some(PathBuf::from(cuda_home));
    }

    if let Ok(cuda_toolkit) = env::var("CUDA_TOOLKIT_ROOT_DIR") {
        return Some(PathBuf::from(cuda_toolkit));
    }

    // Check common installation paths
    let mut common_paths = Vec::new();

    if cfg!(target_os = "windows") {
        // Add generic path first
        common_paths.push(PathBuf::from("C:\\CUDA"));

        // Add version-specific paths for CUDA 12.0 - 12.9
        for minor in (0..=9).rev() {
            common_paths.push(PathBuf::from(format!(
                "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.{minor}"
            )));
        }

        // Add CUDA 11.x versions
        for minor in (0..=8).rev() {
            common_paths.push(PathBuf::from(format!(
                "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.{minor}"
            )));
        }

        // Add future CUDA 13.x support
        for minor in (0..=9).rev() {
            common_paths.push(PathBuf::from(format!(
                "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v13.{minor}"
            )));
        }
    } else if cfg!(target_os = "linux") {
        // Add generic paths first
        common_paths.push(PathBuf::from("/usr/local/cuda"));
        common_paths.push(PathBuf::from("/opt/cuda"));
        common_paths.push(PathBuf::from("/usr/lib/cuda"));

        // Add version-specific paths for CUDA 12.0 - 12.9
        for minor in (0..=9).rev() {
            common_paths.push(PathBuf::from(format!("/usr/local/cuda-12.{minor}")));
            common_paths.push(PathBuf::from(format!("/opt/cuda-12.{minor}")));
        }

        // Add CUDA 11.x versions
        for minor in (0..=8).rev() {
            common_paths.push(PathBuf::from(format!("/usr/local/cuda-11.{minor}")));
            common_paths.push(PathBuf::from(format!("/opt/cuda-11.{minor}")));
        }

        // Add future CUDA 13.x support
        for minor in (0..=9).rev() {
            common_paths.push(PathBuf::from(format!("/usr/local/cuda-13.{minor}")));
            common_paths.push(PathBuf::from(format!("/opt/cuda-13.{minor}")));
        }

        // Add distribution-specific paths
        common_paths.push(PathBuf::from("/usr/lib/x86_64-linux-gnu/cuda"));
        common_paths.push(PathBuf::from("/usr/share/cuda"));
    } else if cfg!(target_os = "macos") {
        // Add generic path first
        common_paths.push(PathBuf::from("/usr/local/cuda"));

        // Add version-specific paths for CUDA 12.0 - 12.9
        for minor in (0..=9).rev() {
            common_paths.push(PathBuf::from(format!("/Developer/NVIDIA/CUDA-12.{minor}")));
            common_paths.push(PathBuf::from(format!("/usr/local/cuda-12.{minor}")));
        }

        // Add CUDA 11.x versions
        for minor in (0..=8).rev() {
            common_paths.push(PathBuf::from(format!("/Developer/NVIDIA/CUDA-11.{minor}")));
            common_paths.push(PathBuf::from(format!("/usr/local/cuda-11.{minor}")));
        }

        // Add future CUDA 13.x support
        for minor in (0..=9).rev() {
            common_paths.push(PathBuf::from(format!("/Developer/NVIDIA/CUDA-13.{minor}")));
            common_paths.push(PathBuf::from(format!("/usr/local/cuda-13.{minor}")));
        }
    }

    // Find first existing path
    for path in common_paths {
        if path.exists() {
            return Some(path);
        }
    }

    // Try nvidia-smi to detect CUDA runtime
    if let Ok(output) = std::process::Command::new("nvidia-smi")
        .arg("--query")
        .arg("-u")
        .arg("-x")
        .output()
    {
        if output.status.success() {
            // CUDA runtime is available, but we couldn't find the SDK
            // Return None but don't panic - runtime detection will still work
            println!("cargo:warning=NVIDIA driver detected but CUDA SDK not found");
        }
    }

    None
}

fn compile_ptx_kernels() {
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let kernel_path = "src/gpu/cuda_driver/kernels/matrix_multiply.cu";
    let ptx_path = out_dir.join("matrix_multiply.ptx");

    println!("cargo:rerun-if-changed={kernel_path}");

    // Check if nvcc is available
    let nvcc_check = Command::new("which").arg("nvcc").status();

    if nvcc_check.is_ok() && nvcc_check.unwrap().success() {
        // Compile with nvcc if available
        let nvcc_status = Command::new("nvcc")
            .args([
                "-ptx",
                "-o",
                ptx_path.to_str().unwrap(),
                kernel_path,
                "-arch=sm_80",
                "-O3",
            ])
            .status();

        if let Ok(status) = nvcc_status {
            if !status.success() {
                println!(
                    "cargo:warning=Failed to compile CUDA kernel with nvcc, using pre-compiled PTX"
                );
                // Copy pre-compiled PTX as fallback
                copy_precompiled_ptx(&ptx_path);
            }
        } else {
            println!("cargo:warning=Failed to execute nvcc, using pre-compiled PTX");
            copy_precompiled_ptx(&ptx_path);
        }
    } else {
        // Use pre-compiled PTX if nvcc is not available
        copy_precompiled_ptx(&ptx_path);
    }

    // Also handle WSL2 specific paths
    let wsl_cuda_path = "/usr/lib/wsl/lib";
    if Path::new(wsl_cuda_path).exists() {
        println!("cargo:rustc-link-search=native={wsl_cuda_path}");
    }
}

fn copy_precompiled_ptx(ptx_path: &Path) {
    if let Err(e) = fs::copy("src/gpu/cuda_driver/kernels/matrix_multiply.ptx", ptx_path) {
        println!("cargo:warning=Failed to copy pre-compiled PTX: {e}");
        println!("cargo:warning=CUDA Driver matrix multiplication will use embedded PTX");
    }
}
